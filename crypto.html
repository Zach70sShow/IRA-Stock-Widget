<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crypto Panel</title>
  <style>
    :root{
      color-scheme: dark;

      --bg0:#060b14;
      --bg1:#0a1020;

      --card: rgba(255,255,255,0.06);
      --card2: rgba(255,255,255,0.04);
      --stroke: rgba(255,255,255,0.12);
      --stroke2: rgba(255,255,255,0.10);

      --text:#e9eefc;
      --muted: rgba(233,238,252,0.70);

      --teal:#33e6d1;
      --tealGlow: rgba(51,230,209,0.35);

      --pos:#77ffb5;
      --neg:#ff7a7a;

      --radius: 18px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      height:100vh;
      overflow:hidden;
      font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(900px 600px at 70% 30%, rgba(51,230,209,0.10), transparent 60%),
        radial-gradient(900px 600px at 20% 80%, rgba(120,170,255,0.09), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
    }

    /* faint grid overlay */
    body:before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.04) 1px, transparent 1px);
      background-size: 44px 44px;
      opacity:0.12;
      mask-image: radial-gradient(circle at 55% 45%, black 55%, transparent 78%);
    }

    .wrap{
      height:100%;
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }

    .tile{
      flex:1;
      min-height:0;
      border-radius: var(--radius);
      background: var(--card);
      border: 1px solid var(--stroke);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      position:relative;
    }

    .tile:before{
      content:"";
      position:absolute;
      inset:-120px -120px auto auto;
      width: 260px;
      height: 260px;
      background: radial-gradient(circle, rgba(51,230,209,0.16), transparent 65%);
      transform: rotate(20deg);
      pointer-events:none;
    }

    .hdr{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
      padding: 12px 12px 8px 12px;
    }

    .name{
      font-weight: 950;
      letter-spacing: 0.6px;
      font-size: 14px;
      text-transform: uppercase;
      color: rgba(233,238,252,0.86);
      display:flex;
      align-items:center;
      gap:8px;
    }

    .dot{
      width:8px;height:8px;border-radius:99px;
      background: var(--teal);
      box-shadow: 0 0 14px var(--tealGlow);
      flex:none;
    }

    .priceBox{
      text-align:right;
      display:flex;
      flex-direction:column;
      gap: 4px;
    }

    .price{
      font-size: 26px;
      font-weight: 950;
      line-height: 1;
      font-variant-numeric: tabular-nums;
      text-shadow: 0 8px 22px rgba(0,0,0,0.35);
    }

    .chg{
      font-size: 12px;
      font-weight: 900;
      font-variant-numeric: tabular-nums;
    }

    .pos{ color: var(--pos); }
    .neg{ color: var(--neg); }
    .muted{ color: var(--muted); }

    .chartWrap{
      flex:1;
      min-height:0;
      padding: 0 10px 10px 10px;
      display:flex;
    }

    canvas{
      width:100%;
      height:100%;
      background: rgba(0,0,0,0.12);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
    }

    .footer{
      padding: 8px 12px 10px 12px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      border-top: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.18);
      font-size: 11px;
      color: rgba(233,238,252,0.72);
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 5px 10px;
      border-radius: 999px;
      font-weight: 900;
      background: rgba(51,230,209,0.10);
      border: 1px solid rgba(51,230,209,0.22);
      color: rgba(233,238,252,0.90);
      white-space:nowrap;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- BTC -->
    <section class="tile" id="tileBTC">
      <div class="hdr">
        <div class="name"><span class="dot"></span> Bitcoin (BTC)</div>
        <div class="priceBox">
          <div class="price" id="btcPrice">—</div>
          <div class="chg muted" id="btcChg">Loading…</div>
        </div>
      </div>
      <div class="chartWrap">
        <canvas id="btcChart"></canvas>
      </div>
      <div class="footer">
        <div class="pill"><span class="dot"></span><span id="btcStatus">LIVE</span></div>
        <div id="btcUpdated">—</div>
      </div>
    </section>

    <!-- ADA -->
    <section class="tile" id="tileADA">
      <div class="hdr">
        <div class="name"><span class="dot"></span> Cardano (ADA)</div>
        <div class="priceBox">
          <div class="price" id="adaPrice">—</div>
          <div class="chg muted" id="adaChg">Loading…</div>
        </div>
      </div>
      <div class="chartWrap">
        <canvas id="adaChart"></canvas>
      </div>
      <div class="footer">
        <div class="pill"><span class="dot"></span><span id="adaStatus">LIVE</span></div>
        <div id="adaUpdated">—</div>
      </div>
    </section>
  </div>

<script>
  // We purposely avoid API keys.
  // We'll use Coinbase spot price (public) for BTC + ADA and build a local sparkline.
  // Price updates every 30s. Sparkline uses the last N samples.

  const REFRESH_MS = 30_000;
  const MAX_POINTS = 80;

  const state = {
    BTC: { points: [], lastPrice: null, lastTs: 0 },
    ADA: { points: [], lastPrice: null, lastTs: 0 }
  };

  function fmtUsd(n, decimals=2){
    if(n == null || !isFinite(n)) return "—";
    return n.toLocaleString(undefined, { style:"currency", currency:"USD", minimumFractionDigits:decimals, maximumFractionDigits:decimals });
  }

  function fmtPct(n){
    if(n == null || !isFinite(n)) return "—";
    return (n >= 0 ? "+" : "") + n.toFixed(2) + "%";
  }

  function clsFor(n){ return n > 0 ? "pos" : (n < 0 ? "neg" : "muted"); }

  async function fetchCoinbaseSpot(pair){
    // Coinbase public spot endpoint (no key)
    // Example: https://api.coinbase.com/v2/prices/BTC-USD/spot
    const url = `https://api.coinbase.com/v2/prices/${pair}/spot?t=${Date.now()}`;
    const r = await fetch(url, { cache:"no-store" });
    if(!r.ok) throw new Error("spot failed " + r.status);
    const data = await r.json();
    const amt = Number(data?.data?.amount);
    return amt;
  }

  function pushPoint(sym, price){
    const s = state[sym];
    s.points.push(price);
    if(s.points.length > MAX_POINTS) s.points.shift();
  }

  function drawSparkline(canvas, points){
    const ctx = canvas.getContext("2d");
    const dpr = window.devicePixelRatio || 1;

    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(2, Math.floor(rect.width * dpr));
    canvas.height = Math.max(2, Math.floor(rect.height * dpr));

    const w = canvas.width;
    const h = canvas.height;

    // Background
    ctx.clearRect(0,0,w,h);

    // If not enough points, show a little loading ring
    if(!points || points.length < 2){
      ctx.globalAlpha = 0.7;
      ctx.strokeStyle = "rgba(51,230,209,0.55)";
      ctx.lineWidth = 4 * dpr;
      ctx.beginPath();
      ctx.arc(w*0.5, h*0.5, Math.min(w,h)*0.12, 0, Math.PI*1.6);
      ctx.stroke();
      ctx.globalAlpha = 1;
      return;
    }

    // Normalize points
    let min = Math.min(...points);
    let max = Math.max(...points);
    if(max - min < 1e-9){
      max = min + 1;
    }

    const pad = 14 * dpr;
    const innerW = w - pad*2;
    const innerH = h - pad*2;

    const xStep = innerW / (points.length - 1);

    // Path
    ctx.lineJoin = "round";
    ctx.lineCap = "round";

    // Glow
    ctx.beginPath();
    for(let i=0;i<points.length;i++){
      const x = pad + xStep*i;
      const t = (points[i] - min) / (max - min);
      const y = pad + (1 - t) * innerH;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.strokeStyle = "rgba(51,230,209,0.20)";
    ctx.lineWidth = 10 * dpr;
    ctx.stroke();

    // Main line
    ctx.beginPath();
    for(let i=0;i<points.length;i++){
      const x = pad + xStep*i;
      const t = (points[i] - min) / (max - min);
      const y = pad + (1 - t) * innerH;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.strokeStyle = "rgba(51,230,209,0.95)";
    ctx.lineWidth = 3 * dpr;
    ctx.stroke();

    // Fill under
    ctx.globalAlpha = 0.20;
    ctx.lineTo(pad + xStep*(points.length-1), pad + innerH);
    ctx.lineTo(pad, pad + innerH);
    ctx.closePath();
    ctx.fillStyle = "rgba(51,230,209,0.40)";
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  function render(sym){
    const isBTC = sym === "BTC";
    const s = state[sym];

    const priceEl = document.getElementById(isBTC ? "btcPrice" : "adaPrice");
    const chgEl   = document.getElementById(isBTC ? "btcChg" : "adaChg");
    const updEl   = document.getElementById(isBTC ? "btcUpdated" : "adaUpdated");
    const stEl    = document.getElementById(isBTC ? "btcStatus" : "adaStatus");
    const canvas  = document.getElementById(isBTC ? "btcChart" : "adaChart");

    const price = s.lastPrice;

    // Price formatting: BTC usually 2 decimals, ADA 4
    priceEl.textContent = (sym === "BTC")
      ? fmtUsd(price, 2)
      : fmtUsd(price, 4);

    // Change since last sample (not true 24h — it’s “since last refresh”)
    // If you want true 24h % we can add a second endpoint later.
    if(s.points.length >= 2){
      const prev = s.points[s.points.length - 2];
      const pct = prev ? ((price - prev) / prev) * 100 : null;
      chgEl.textContent = `${fmtPct(pct)} (since last)`;
      chgEl.className = "chg " + clsFor(pct);
    } else {
      chgEl.textContent = "Collecting data…";
      chgEl.className = "chg muted";
    }

    updEl.textContent = "Updated " + new Date(s.lastTs).toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
    stEl.textContent = "LIVE";

    drawSparkline(canvas, s.points);
  }

  async function tickOnce(){
    // Fetch both in parallel
    try{
      const [btc, ada] = await Promise.all([
        fetchCoinbaseSpot("BTC-USD"),
        fetchCoinbaseSpot("ADA-USD")
      ]);

      state.BTC.lastPrice = btc;
      state.BTC.lastTs = Date.now();
      pushPoint("BTC", btc);

      state.ADA.lastPrice = ada;
      state.ADA.lastTs = Date.now();
      pushPoint("ADA", ada);

      render("BTC");
      render("ADA");
    } catch(e){
      console.error(e);
      // show degraded status
      document.getElementById("btcStatus").textContent = "SYNC";
      document.getElementById("adaStatus").textContent = "SYNC";
      document.getElementById("btcChg").textContent = "API hiccup…";
      document.getElementById("adaChg").textContent = "API hiccup…";
    }
  }

  function handleResize(){
    // Redraw charts on resize
    render("BTC");
    render("ADA");
  }

  (async function init(){
    await tickOnce();
    setInterval(tickOnce, REFRESH_MS);
    window.addEventListener("resize", handleResize);
  })();
</script>
</body>
</html>
